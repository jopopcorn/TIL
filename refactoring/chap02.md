# Refactoring

리팩터링: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법. 혹은 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하는 행위

### 리팩터링 ≠ 재구성 (restructuring) ?!

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중파구 리팩터링한 것이 아니다.

📝 재구성: 코드베이스를 정리하거나 구조를 바꾸는 모든 작업

→ 리팩터링은 재구성 중 특수한 한 형태로 본다.

- 리팩터링은 하기 전과 후의 코드가 똑같이 동작해야 한다.
- 성능이 변할 수 있다 해도, 사용자 관점에서는 달라지는 점이 없어야 한다.        
        
### 리팩터링 목적

코드를 이해하고 수정하기 쉽게 만드는 것 (성능은 좋아질 수도, 나빠질 수도 있다)

### 🤠 두 개의 모자 | 소프트웨어를 개발할 때의 목적을 명확히 구분하라

소프트웨어를 개발할 때 목적에 따라 두 모자를 바꿔 쓴다. 항상 내가 쓰고 있는 모자가 
무엇인지, 그에 따른 미묘한 작업 방식의 차이가 무엇인지 분명하게 인식해야 한다.

🧢 '기능 추가' : 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다.

🧢 '리팩터링' : 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다. 테스트도 새로 만들지 않는다. 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.

---

## 리팩터링하는 이유

- 소프트웨어 설계가 좋아진다.
    - 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.
    - 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다.
- 소프트웨어를 이해하기 쉬워진다.
    - 잘 작동하지만 이상적인 구조는 아닌 코드가 있다면, 잠깐 시간을 내서 리팩터링해보자. 코드의 목적(즉, 작성자의 의도)을 더 명확하게 전달하도록 개선할 수 있다.
- 버그를 쉽게 찾을 수 있다.
    - 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.
    - 프로그램 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다.
- 프로그래밍 속도를 높일 수 있다.
    - 리팩터링을 하지 않았던 개발자들의 경험에 의하면, 초기에는 진척이 빨랐지만 현재는 새 기능을 하나 추가하는 데 훨씬 오래 걸린다는 말을 많이 한다. 게다가 기능을 추가하고 나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸린다.
    - 리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다.
    - 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다.

> 난 뛰어난 프로그래머가 아니에요. 
> 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요. 
> -켄트 백

### 언제 리팩터링해야 할까?

3의 법칙 '스트라이크 세 번이면 리팩터링하라' (삼진 리팩터링)

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
    - 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.
    - 다들 "직진"을 외치더라도, 때로는 "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"고 말할 줄 알아야 한다.
    - 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기 훨씬 편하다. 또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다.
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
    - 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지가 없는지 찾아본다.
    - ***자잘한 세부 코드에 이해를 위한 리팩터링**을 하면, 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다.
    - 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

        ***어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나누기도 하는 리팩터링**

- 쓰레기 줍기 리팩터링
    - 로직이 쓸데없이 복잡하거나, 매개변수화한 함수가 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놓는 경우 등 비효율적으로 처리한 코드를 발견할 때가 있다. 이때 약간 절충을 해야 한다.
    - 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.
    - 수정하려면 몇 시간이 걸리고 당장은 더 급한 일이 있을 수 있다. 그렇더라도 조금이나마 개선해두는 것이 좋다.
- 계획된 리팩터링과 수시로 하는 리팩터링
    - 리팩터링은 눈앞의 문제뿐 아니라 앞으로 할 작업에도 도움을 준다.
    - 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.
    - 보기 싫은 코드를 발견하면 리팩터링하자. 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
    - 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자.
    - 소프트웨어 개발을 끝이 있는 작업으로 보면 안된다.
    - 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.
    - 리팩터링 커밋과 기능 추가 커밋을 분리한다고 해서 무조건 좋은 것이 아님을 명심하라. 팀에 적합한 방식을 실험을 통해 찾아내야 한다.
- 오래 걸리는 리팩터링
    - 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.
    - 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다(이 전략을 추상화로 갈아타기라 한다).
- 코드 리뷰에 리팩터링 활용하기
    - 코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다.
    - 대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해하는 데도 도움된다.
    - 다른 사람의 아이디어를 얻을 수 있다.
    - 깔끔한 코드를 작성하는 데에도 굉장히 중요하다.
    - 서로의 기여가 일을 더욱 편하게 만들어주므로 기회가 닿는 대로 코드 리뷰를 한다.
    - 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다.

> 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고,
가장 빠른 방법은 리팩터링이다.

### 리팩터링하지 말아야 할 때

- 지저분한 코드를 발견해도 굳이 수정할 필요가 없을 때
- 외부 API 다루듯 호출해서 쓰는 코드일 때

    → 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.

**But, 대부분은 리팩터링을 더 자주 하도록 노력해야 한다.**

### 리팩터링의 본질

- 오로지 경제적인 이유로 하는 것
- 개발 기간을 단축하고자 하는 것
- 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.

이를 스스로 인식하는 데 그치지 말고 다른 사람과 대화할 때도 이 점을 명심해야 한다.

### 리팩터링 시 고려할 문제

- 브랜치
    - 기능 브랜치 방식은 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기 어려워진다. 따라서 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다.
    - 지속적 통합(Continuous Integration, CI)에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다.
    - 기능별 브랜치를 사용하면 절대 안 된다는 말은 아니다. 브랜치를 자주 통합할 수만 있다면 문제가 발생할 가능성을 크게 줄일 수 있다.
- 테스팅
    - 리팩터링하기 위해서는 (대부분의 경우에) ***자가 테스트 코드**를 마련해야 한다.
    - 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다.
    - ⭐ 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다.
    - 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소한다.

        ***스스로 성공/실패를 판단하는 테스트**

- 레거시 코드
    - 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.
    - 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다.

        → 「레거시 코드 활용 전략」의 주요 내용

    - 서로 관련된 부분끼리 나눠서 하나씩 공략한다.
    - 캠핑 규칙에 따라 처음 왔을 때보다 코드를 깨끗하게 치우는 것이다.
    - 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다.

[머지와 통합 비교](https://www.notion.so/725b499b3af046ca9553547fd144f251)

---

### 테스트 주도 개발 (Test-Driven Development, TDD)

자가 테스트 코드와 리팩터링을 묶은 것

+) 리팩터링에 대한 추가적인 사항

- 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.
- 팀으로 개발하면서 리팩터링 하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 한다.
- 자가 테스트 코드, 지속적 통합(CI), 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘한다.
   
### 성능 최적화

- 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 쉽게 만드는데 집중한다.
- 리팩터링할 때처럼 최적화를 위한 수정도 작은 단계를 나눠서 진행한다.
- 각 단계에서 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다. 성능이 개선되지 않았다면 수정 내용을 돌린다. 이런 식으로 사용자가 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 계속한다.
- 프로그램을 잘 리팩터링해두면 성능 튜닝에 투입할 시간을 벌 수 있고, 성능을 더 세밀하게 분석할 수 있다.

> 시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다.
> 그러면 새로운 사실을 배우게 되는데, 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다.
> -론 제프리
