### ANR

- Application Not Responding의 줄임말
- UI Thread 에서 Network IO, File IO, 반복문 등 지나치게 많은 시간을 소요하게 될 경우 Not Response 로 인한 에러가 발생
- 화면을 터치하고나서 5초안에 응답이 없는경우 발생함. BroadcastReceiver의 이슈도 있지만 대부분의 경우는 위의 이유 때문
- 백그라운드로 돌릴법한 무거운 작업을 UI 스레드에서 돌리는 경우에 발생함
- RxJava, Coroutine에서 스레드 스케줄러 관리를 작업에 맞게 잘 전환 시켜줘야 하는 이유이기도 함
- anr 이 발생한 경우 /data/anr/trace.txt 를 추출하여 어느 쓰레드가 블럭하고 어느 쓰레드가 대기중인지 파악할 수 있다. 일부 기기는 바로 추출이 가능하며 일부 기기는 adb-shell 로 해당 파일을 sdcard 영역으로 복사한 다음 추출할 수 있다
- Main Thread는 메시지 Queue 형식으로 동작하는데, 해당 Queue에서 일정 시간내에 작업이 완료되지 않으면 ANR이 발생함
- ANR이 발생하는 기준은 Main Thread에서 동작하고 있는 Application Component에 따라 조금씩 달라짐. 예를들어 Activity의 경우 5초. Broadcast Receiver의 경우 조금 더 긴 경우가 많음 (10초)
  


### Overdraw

- 화면에 픽셀이 같은 프레임에서 몇 번 덧칠됐는지 의미하는 용어
- 요즘에는 뷰를 쌓고 겹쳐서 아름다운 디자인을 만들지만 한편으로는 overdraw가 많아지는 것임
- 성능 최적화를 위해서는 overdraw를 최소화해야 함
- 스마트폰을 개발자 모드로 들어가서 Show GPU Overdraw 옵션을 설정하기
- 안드로이드는 overdraw가 발생하는 구역을 다른 색으로 표시함
- 한 번만 렌더링된 픽셀은 색조 없이 본래 색으로 표시됨
- overdraw를 줄이는 목적을 달성하기 위해 두 가지 방법을 활용할 수 있음. 첫 단계는 배경과 drawable들이 최종 뷰에 포함되지 않는다면 제외하는 것임. 두 번째 단계는 화면에서 뷰가 가려질 부분을 명시해주는 것임. 그럴 경우 CPU와 GPU 오버헤드를 줄일 수 있게 됨
  
1X Overdraw : 해당 픽셀을 한 번 수정했다

2X Overdraw : 해당 픽셀을 두 번 수정했다

3X Overdraw : 해당 픽셀을 세 번 수정했다

4X Overdraw : 해당 픽셀을 네 번 수정했다

UI 개체 일부는 최종 화면에 보여지지 않을 수 있다. 가려진 부분은 그릴 필요가 없다. 이런 상황에서는 clipping을 활용해 GPU 자원 낭비를 예방해야 한다. 
clipRect를 통해 밑에 쌓여져 있는 뷰들(overdraw된 것들)을 렌더링시키지 않도록 한다. 다행히도 clipping 범위에 있는지 확인하는 로직은 직접 작성하지 않고, quickReject()를 사용한다.
canvas.quickReject() 메서드는 특정 구역이 테두리 밖에 있는지 알려주기 때문에 그림이 범위 밖에 있으면 그리지 않는다.
커스텀 뷰에 대한 이야기는 다음에 정리하고 실습해볼 것이다.

  
+) Hierarchy Viewer → Depracated. Layout Inspector로 레이아웃 디버그
Hierarchy Viewer는 UI 구조 전체를 시각적으로 한눈에 보여주며, 해당 구조의 각 뷰에 대해서 뷰의 상대적 렌더링 성능을 보여준다. 
  

성능 문제는 보통 2가지 종류로 나눌 수 있다.

1. 단일의 느린 함수: 함수 1개가 예상 속도의 2배, 50배 이상 걸리는 것을 말한다. 느린 함수를 찾아서 코드를 검토하고 문제를 식별한 후 여러 방법을 통해 고치면 된다.
2. 몇 백 개의 함수들이 예상한 속도보다 1ms씩 더 오래 걸려서 최종 프로그램 실행 시간이 예상보다 100ms 이상으로 늘어나는 것이다. 이런 종류의 문제는 찾기도 힘들고 고치기는 더 힘들다. 결국 코드 전체를 1줄씩 일일이 검토해 성능을 조금씩 늘릴 수 있는 코드를 모두 찾으려고 해야하기 때문이다.

이런 조그만 성능 문제를 해결하기 위해서는 프로파일링에 의존해야 한다. 프로파일링은 코드의 속도를 측정해 코드의 어느 부분이 느린지 파악하고 조금씩 수정한 후 속도를 재측정하는 것이다. 또 문제를 일으키는 함수를 찾은 후엔 해당 함수의 코드를 한 줄씩 측정하며 해당 함수가 호출하는 다른 함수들도 측정해야 한다. 

→ CPU 프로파일러를 통해 CPU 사용량을 검사한다.


### Memory Leaks
- 잘 관리하지 못해 반납되지 않은 메모리 조각을 메모리 누수라고 함
- 애플리케이션이 더 이상 사용하지 않는 객체를 GC가 가려내지 못하는 상황을 일컫음
- 메모리 관리 언어의 런타임은 할당된 메모리를 추적하고 애플리케이션이 더 이상 필요하지 않은 메모리는 다시 시스템으로 반납함
- 메모리 관리 환경에서 메모리를 회수하는 기술은 가비지 컬렉션이라고 부름
- 메모리 누수가 지속되면 메모리 힙의 가용한 공간이 매 세대마다 줄어듦. 그래서 GC가 더 자주 실행됨 (메모리 확보를 위해)
  
가비지 컬렉션의 기본적 원칙은 다음과 같다.

1. 프로그램에서 더 이상 접근할 수 없는 데이터 객체 찾기 (ex. 코드에서 더 이상 참조하지 않는 메모리 주소 같은 것)
2. 이런 객체가 사용하던 리소스 회수하기

한 프레임에서 발생하는 GC 이벤트 개수를 줄이려면 여러분의 애플리케이션의 메모리 사용을 최적화해야 한다. 
메모리 누수는 감지하기 어렵게 천천히 쌓여 여러분이 메모리 누수를 발견하는데 며칠 혹은 몇 주가 걸릴 수 있다. 심지어 메모리 누수가 있는지 모를 수도 있다. 
Memory Profiler를 통해 메모리 누수를 실시간으로 관찰하고 추가적인 메모리 누수 흔적을 살펴볼 수 있다. 
메모리 누수를 발견하기 위해서는 충분한 시간과 적절한 시험 환경이 필요하다. 그리고 메모리 할당을 올바르게 해도 누수가 발생할 수 있다. 

메모리 누수를 방지하는 요령은 코드에서 생성하는 객체의 수명을 파악해 더 이상 참조할 필요가 없으면 제거하라.

**코드에서 메모리 누수 추적**

Custom View의 `init`방법을 살펴보면..

```java
  private void init () {      
    ListenerCollector collector = new ListenerCollector();
    collector.setListener (this, mListener);
  }
```

특정 활동에 대해 모든 뷰 리스너를 저장하는 것은 겉보기에 무해해 보이지만, 참조를 정리하지 않은 경우 우연히 느린 누수를 생성 할 수 있다. 다음과 같은 경우를 예시로 들겠다.

`collector.setListener(this, mListener);`

이 문제는 활동이 destroy되고 새로운 활동이 create될 때 더욱 복잡해진다. 이 예에서 디바이스 방향 변경으로 인해 새 activity가 생성되면 뷰에 의해 연관된 리스너가 생성되지만, activity가 파괴되면 해당 리스너가 해제되지 않는다. 즉, Java의 GC에서 리스너를 회수 할 수 없으므로 메모리 누수가 발생한다.

장치가 회전되고 현재 활동의 onStop() 메서드가 호출되면 리스너를 보기 위해 불필요한 참조를 모두 정리해야 한다.

### Memory Profiler
- 메모리 프로파일러는 애플리케이션이 시간에 지남에 따라 메모리를 어떻게 사용하는지 보여줌
- 프로세스가 각 시점에 사용하는 메모리 양을 볼 수 있음
- 할당 중인 메모리가 급격하게 줄어드는 경우가 있는데 이 구간이 GC가 실행된 구간
- 뾰족한 스파이크가 생기는 경우는 애플리케이션이 짧은 시간 동안 많은 양의 메모리를 할당하고 즉시 반납하기 때문에 생기는 것
- GC를 하는 시간이 길어질수록 렌더링과 오디오 스트리밍 등 다른 작업을 할 시간이 줄어듦

#### Memory Churn
- 힙의 할당된 메모리 양이 너무 커지면 GC 이벤트가 실행되서 더 이상 필요하지 않는 객체를 해제해 메모리를 확보함
- 메모리 churn은 짧은 현상 안에 여러 개의 객체를 메모리에 할당하는 현상을 말함
- 고성능 애플리케이션을 만들기 위해서는 선언문을 식별해 루프 밖으로 꺼내줘야 함

GC 이벤트가 자주 발생하는 경우

1. 문자열에 concatenation(더하기를) 하기 위해 새로운 문자 배열이 생성되어야 한다는 점
2. 루프 안에서 문자 배열의 생성이 짧은 시간 동안 여러 번 발생한다는 점

해결 방법: 열을 생성할 때마다 1개의 문자씩 concatenate 하지 않고 StringBuilder 인스턴스를 활용해 각 줄을 하나의 문자열로 생성한다.

```java
for(int i=0;i<lotOfInts.length;i++){
	String rowAsStr = "";
	for(int j=0;j<lotsOfInts[i].length;j++){
		rowAsStr += getSorted(lotsOfInts[i])[j];
		if(j < (lotsOfInts[i].length - 1)){
			rowAsStr += ", ";
		}
	}
}
```

```java
// StringBuilder가 루프 밖에서 선언됐으므로 StringBuilder는 메모리가 한 번만 할당됨
StringBuilder sb = new StringBuilder(10000);
String rowAsStr = "";
    for(int i = 0; i < lotsOfInts.length; i++) {
    // 루프를 반복할 때마다 StringBuilder를 버퍼로 사용해 StringBuilder를 비우고
		// 다시 정수로 이루어진 문자열을 지정함
    sb.delete(0, rowAsStr.length()); 
    for (int j = 0; j < lotsOfInts[i].length; j++) {
        sb.append(getSorted(lotsOfInts[i])[j]);
        if(j < (lotsOfInts[i].length - 1)){
            sb.append(", ");
            }
        }
        rowAsStr = sb.toString();
        Log.i("CachingActivityExercise", "Row " + i + ": " + rowAsStr);
}
```
